<html>

<head>
<title>LAPPS Coreference</title>
<link rel="stylesheet" href="../css/main.css" type="text/css" />
</head>

<body>

<h1>Coreference for LAPPS</h2>

<p>Version 2, September 2014, Marc Verhagen, Brandeis University</p>


<h2>Some Linguistics</h2>

<p>Coreference occurs when two or more text elements have the same referent,
that is, they refer to the same person or thing. One of these text elements is a
full form. There are several kinds of coreference:</p>

<ol>

<li><i>Joe Doe hurt himself</i>. The anophor <i>himself</i> refers to the same thing as
the full form <i>himself</i>. In this case the full form is called the antecedent.

<li><i>Despite her reluctance, Jane Doe understood the issue</i>. The cataphor <i>her</i>
occurs before the postcedent (the full form).

<li><i>Carol told Bob to attend the party. They arrived together</i>. The anaphor
<i>they</i> has a split antecedent.

<li><i>The man refuses to help. The jerk thinks he is too good for
that</i>. Coreferring noun phrases, where the second noun phrase is a
predication over the first.

</ol>

<p>Much of this is taken from <a href="http://en.wikipedia.org/wiki/Coreference"
target="_blank">http://en.wikipedia.org/wiki/Coreference</a>.</p>


<h2>Coreference output examples</h2>

<p>The <b>Stanford tools</b> create a list of mentions for each coreference
chain and assigns the "representative" attribute to one of the elements. Each
mention refers to sentence and token identifiers. For the text <i>"John is
sick. He is home. Jill sees her dog."</i>, we have the following output:</p>

<pre class="example">
&lt;root>
  &lt;document>
    &lt;sentences>
      &lt;sentence id="1">
        &lt;tokens>
          &lt;token id="1">&lt;word>John&lt/word>...&lt;/token>
          ...
        &lt;/tokens>
        &lt;parse>(ROOT (S (NP (NNP John)) (VP (VBZ is) (ADJP (JJ sick))) (. .))) &lt;/parse>
        &lt;dependencies type="basic-dependencies">...&lt;/dependencies>
        &lt;dependencies type="collapsed-dependencies">...&lt;/dependencies>
        &lt;dependencies type="collapsed-ccprocessed-dependencies">...&lt;/dependencies>
      &lt;/sentence>
      &lt;sentence id="2">...&lt;/sentence>
      &lt;sentence id="3">...&lt;/sentence>
    &lt;/sentences>
    &lt;coreference>
      &lt;coreference>
        &lt;mention representative="true">
          &lt;sentence>1&lt;/sentence>&lt;start>1&lt;/start>&lt;end>2&lt;/end>&lt;head>1&lt;/head>&lt;text>John&lt;/text>
        &lt;/mention>
        &lt;mention>
          &lt;sentence>2&lt;/sentence>&lt;start>1&lt;/start>&lt;end>2&lt;/end>&lt;head>1&lt;/head>&lt;text>He&lt;/text>
        &lt;/mention>
      &lt;/coreference>
      &lt;coreference>
        &lt;mention representative="true">
          &lt;sentence>3&lt;/sentence>&lt;start>1&lt;/start>&lt;end>2&lt;/end>&lt;head>1&lt;/head>&lt;text>Jill&lt;/text>
        &lt;/mention>
        &lt;mention>
          &lt;sentence>3&lt;/sentence>&lt;start>3&lt;/start>&lt;end>4&lt;/end>&lt;head>3&lt;/head>&lt;text>her&lt;/text>
        &lt;/mention>
      &lt;/coreference>
    &lt;/coreference>
  &lt;/document>
&lt;/root>
</pre>

<p>Here is some output from the <b>OpenNLP coreference</b>:</p>

<pre class="example">
OpenNLP Coreference 
-------------------------------------------------------------------------------------------------------
Input sentences 1 ::
Carol told Bob to attend the party. They arrived together.

Sentence#1 parse after POS & NER tag:
(TOP (S (NP (NNP Carol)) (VP (VBD told) (NP (NNP Bob)) (S (VP (TO to) (VP (VB attend) (NP (DT the) (NN party))))))(. .)))

Sentence#2 parse after POS & NER tag:
(TOP (S (NP (PRP They)) (VP (VBD arrived) (ADVP (RB together)))(. .)))

Now displaying all discourse entities::
        Mention set:: [ Bob  :: They  ]
        Mention set:: [ the party  ]
        Mention set:: [ Carol  ]
</pre>

<p>Here too, we have sets of mentions. From this print it is not possible to see
how internally mentions in the data structure refer to text elements, whether it
is by pointing to sentence and token identifiers, as with the Stanford tool, or
to nodes in the parse tree. This example, by the way, shows that split
antecedents are not dealt with by OpenNLP (at least, not in this case).</p>

<p>And here is the <b>ANNIE coreference</b> output from GATE. This is the
coreference component as wrapped at Vassar
(<a href="http://grid.anc.org:8080/service_manager/wsdl/anc:gate.coref_1.3.5">http://grid.anc.org:8080/service_manager/wsdl/anc:gate.coref_1.3.5</a>. I
have removed the className and itemClassName attributes to make it easier to
read.</p>

<pre class="example">
&lt;Annotation Id="28" Type="Person" StartNode="9" EndNode="13">
&lt;Feature>
  &lt;Name>matches&lt;/Name>
  &lt;Value>28;31&lt;/Value>
&lt;/Feature>
&lt;Feature>
  &lt;Name>string&lt;/Name>
  &lt;Value>John&lt;/Value>
&lt;/Feature>
&lt;/Annotation>
&lt;Annotation Id="31" Type="Person" StartNode="27" EndNode="30">
&lt;Feature>
  &lt;Name>ENTITY_MENTION_TYPE&lt;/Name>
  &lt;Value>PRONOUN&lt;/Value>
&lt;/Feature>
&lt;Feature>
  &lt;Name>antecedent_offset&lt;/Name>
  &lt;Value>9&lt;/Value>
&lt;/Feature>
&lt;Feature>
  &lt;Name>matches&lt;/Name>
  &lt;Value>28;31&lt;/Value>
&lt;/Feature>
&lt;/Annotation>
</pre>

<p>This is a fragment of the result for <i>There is John Smith. I saw him in
London</i>. This particular result was obtained from a pipeline where the
coreference occurred after named entity recognition. Without NER, there are
no coreference results (this may be a feature of the particular coreference
coponent wrapped). The NER found <i>John</i> and <i>him</i> as persons, but
not <i>Smith</i>. Coreference information is added to the Person
annotations. StartNode and EndNode refer to the character offsets, whereas
matches refers to the annotation object identifiers.

<p>Currently, we already have a default JSON structure for this because the
converters keep all features:</p>

<pre class="example">
{
  "@type" : "Person",
  "id" : "28",
  "start" : 9,
  "end" : 13,
  "features" : {
    "word" : "John",
    "matches" : [ 28, 31 ] }
}, 
{
  "@type" : "Person",
  "id" : "31",
  "start" : 27,
  "end" : 30,
  "features" : {
    "matches" : [ 28, 31 ],
    "antecedent_offset" : 9,
    "ENTITY_MENTION_TYPE" : "PRONOUN" }
}
</pre>

<p>This is not how we want to represent coreference though.</p>


<h2>Coreference in the LAPPS format</h2>

<p>The LAPPS coreference format has been discussed in two tech meetings. An
  <a href="coref-v1.html">earlier version</a> of this document
  was input to the second meeting and it presented seven JSON structures for
  deliberation. This version discards most of those structures (as well as many
  irritating small errors), but summarizes some of the discussion in the context
  of a couple of questions. The relevance of many of these questions are not
  limited to coreference, even though they came up in this context.</p>

<dl class="nicer">

<dt>Can elements in the coreference view refer to identifiers in other
views?</dt>

<dd>There were strong sentiments to allow this. It does not duplicate
  information and makes for potentially more compact representations. In
  addition, Di had a reason for why this is helpful for evaluation, but I forgot
  the particulars. Some of the JSON representations proposed assumed that
  referring to other views was not allowed and therefore they repeated token
  information, these representations were dropped.</dd>

<dt>How deeply nested do we allow our JSON datastructure to be?</dt>

<dd>This refers to how much embedded structure we allow in the JSON objects that
  are in the annotations list. So far, the Token elements in this list just have
  one sub structure: the dictionary of features. The current proposed structures
  extend this a tiny bit by allowing lists for some attributes. All three
  examples of coreference in the previous section (Stanford, OpenNLP and GATE)
  all use a set or list to group mentions/matches. The only way to avoid this
  would be to introduce annotation objects in a coreference chain that link just
  two elements of a chain. This question on nesting becomes more salient when we
  start wrapping tree structures.</dd>

<dt>Is coreference its own annotation object?</dt>

<dd>Yes. Nobody liked the approach of having corefence expressed as an attribute
or set of attributes on Token or Person objects (which is what GATE does). From
this it may follow that Coreference will have its own page in the LAPPS
vocabulary.</dd>

<dt>Is coreference expressed as a coreference chain (linked list) or as a set?</dt>
 
<dd>In the first case, each link in the chain would be represented by a
Coreference object, which would have references to the two objects linked. The
previous version of this document had this as an option, but it ran into a few
little snags. Using a set to represent a list of mentions is common to all three
example coreference modules in the previous section. One advantage of using a
list may be that no list values are needed inside the Coreference object. We
felt that using a set was the better way.</dd>

<dt>How do we represent the text elements that are coreferring?</dt>

<dd>In some cases, there will be annotation objects in another view that can be
  used and in some cases new objects will need to be made. We discussed a
  Markable object that could fill this need.</dd>

<dt>Do we want to aim for views that somehow give away what views they depend on?</dt>

<dd>The metadata of a view specify who created the view. The metadata of this
  producer will have input requirements specified, but won't tell you where to
  get them. The output data in the views do not necessarily say what other view
  data were used, excepts when an object refers to an identifier in another
  view. But these identifiers are not unique in our current scheme (see
  below). We could add metadata that says what views were consumed, but that is
  adding more work to the wrapper. And it is not even clear whether this
  question is actually important.</dd>

<dt>What is the status of the id attribute on the annotation objects?</dt>

<dd>This is tricky from a conceptual angle (I think). We now have a situation
  where two views (from the tokenizer and tagger for example) can have Token
  objects with the same identifier. Is this confusing? I find it somehwat
  confusing to have two different JSON objects with the same identifier (they
  are different because the same Token in the tagger view has added
  attributes). Are these identifiers really references to some underlying object
  that we imply, but that does not occur in the representation explicitly? And
  do we need the identifiers for the Token objects with the same text span to be
  the same? We don't really because the Token objects also have the start and
  end offsets which are identical for the two. The identical identifiers do
  indicate that the two tokens in the two views really are the same token, if we
  require each token identifier to be unique to the document, then we loose
  this. We can make it work either way, the issue may just be to decide on what
  is easier to explain to outsiders.</dd>


<dt>Can we maintain schema similar to Steve Cassidy's?</dt>

<dd>This is an open question and we cannot say anything intelligent about it
  right now. We would need to get examples on how coreference plays out for the
  Australian National Corpus Initiative.</dd>


</dl>

<p>Time for some coreference representations in JSON. The examples below are all
for the simple phrase <i>Sue sees herself</i>. The JSON is fairly informal, just
showing the bits and pieces that are relevant to the discussion.</p>

<p>We introduce a new annotation type Coreference. It has a list of mentions and
an optional representative attribute. The mentions and the representative are
all lists of identifiers. They have to be a list because the the coreferring
entity could have multiple tokens. It may well be that just having the
identifier is too simplistic and a more complex structurea may be called for. In
this example there is a somewhat deeper structure then we have used before due
to the mentions list. Instead of repeating the tokens inside of mentions or
elsewhere in the Coreference view, we refer to identifiers in the Token
view. This is different from the part-of-speech view, where the Token objects
are repeated. This difference can be motivated by noting that posTag is a
feature of Token.</p>

<pre class="example">
"views": [ 
  { "metadata": {
      "contains": {
      "Coreference": {
        "producer": "edu.brandeis.cs.lappsgrid.xxxx.coref:n.n.n",
        "type": "coref:xxxx" },
      "Token": {
        "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:n.n.n",
        "type": "tokenizer:opennlp" }}},
    "annotations": [ 
       { "@type": "Token", "id": "tok0", "features": { "word": "Sue" }},
       { "@type": "Token", "id": "tok1", "features": { "word": "sees" }},
       { "@type": "Token", "id": "tok2", "features": { "word": "herself" }} ] },
  { "metadata": {
      "contains": {
        "Token": {
          "producer": "edu.brandeis.cs.lappsgrid.xxxx.coref:n.n.n",
          "type": "coref:xxxx" }}},
    "annotations": [
       { "@type": "Coreference", 
         "id": "coref0", 
         "mentions": [ ["tok0"], ["tok2"] ],
         "representative": ["tok0"] }]}]
</pre>

<p>What if we do not have tokens (or other annotations) that the mentions can
refer to? We then need to create new objects in the coref view. Nancy suggested
to use a Markable type. Markable seems a decent choice, and so does Annotation
or some other general type. If we choose to take Markable, then it would
probably need to be a subtype of Annotation
in <a href="http://vocab.lappsgrid.org/">http://vocab.lappsgrid.org/</a> and
maybe existing types like Token and Sentence should be under Markable and maybe
there should be something called Relation as another subtype of Annotation. In
any case, assuming we use Markable, we could have the following JSON.</p>

<pre class="example">
"views": [ 
  { "metadata": {
      "contains": {
        "Coreference": {
          "producer": "edu.brandeis.cs.lappsgrid.xxxx.coref:n.n.n",
          "type": "coref:xxxx" },
        "Markable": {
          "producer": "edu.brandeis.cs.lappsgrid.xxxx.coref:n.n.n",
          "type": "coref:xxxx" }}},
    "annotations": [ 
       { "@type": "Markable", "id": "m0", "features": { "word": "Sue" }},
       { "@type": "Markable", "id": "m1", "features": { "word": "herself" }} ] },
       { "@type": "Coreference", 
         "id": "coref0", 
         "mentions": [ "m0", "m1" ],
	 "representative": "m0" }]}]
</pre>

<p>The mentions and the representative are not lists anymore since the markables
are not resticted to being single tokens. The above punts a bit on what exactly
should be attributes of a Markable. In addition, it might be suboptimal to have
coreference represented in two different ways: one with markables and one
without, which is what we have now. We could declare the representation above as
the right one and require the markables. If there are no other object to refer
to, then the markable would specify the character offsets:</p>

<pre class="example">
{ 
   "@type": "Markable", 
   "id": "m0", 
   "start": 0,
   "end": 4,
   "features": { "word": "Sue" }
}
</pre>

<p>And if there are other objects, then in addition to the start and end there
would also be a list of references to other objects:</p>

<pre class="example">
{ 
   "@type": "Markable", 
   "id": "m0", 
   "start": 0,
   "end": 4,
   "targets": ["tok0"],
   "features": { "word": "Sue" }
}
</pre>

</body>
</html>
