<html>

<head>
<title>LIF Coreference</title>
<link rel="stylesheet" href="../css/main.css" type="text/css" />
</head>

<body>

<p>
  <a href="index.html">LIF</a>
> <a href="">coreference</a>
</p>

<h1>Coreference in LIF</h1>

<p>Version 3, October 2014</p>

<p>This document contains a proposal on how to represent coreference in the
Lapps Interchange Format. It is based on a <a href="coref-v2.html">prior
version</a> of this document and subsequent discussion at a LAPPS meeting at
Vassar College with Nancy Ide, Keith Suderman, Di Wang and Chunqi Shi.</p>

<p>
[ <a href="#linguistics">linguistics</a>
| <a href="#output">tool output</a>
| <a href="#lif">coreference in LIF</a>
]
</p>


<a name="linguistics"></a>
<h2>Some Linguistics</h2>

<p>Coreference occurs when two or more text elements have the same referent,
that is, they refer to the same person or thing. One of these text elements is a
full form. There are several kinds of coreference:</p>

<ol>

<li><i>Joe Doe hurt himself</i>. The anophor <i>himself</i> refers to the same thing as
the full form <i>himself</i>. In this case the full form is called the antecedent.

<li><i>Despite her reluctance, Jane Doe understood the issue</i>. The cataphor <i>her</i>
occurs before the postcedent (the full form).

<li><i>Carol told Bob to attend the party. They arrived together</i>. The anaphor
<i>they</i> has a split antecedent.

<li><i>The man refuses to help. The jerk thinks he is too good for
that</i>. Coreferring noun phrases, where the second noun phrase is a
predication over the first.

</ol>

<p>Much of this is taken from <a href="http://en.wikipedia.org/wiki/Coreference"
target="_blank">http://en.wikipedia.org/wiki/Coreference</a>.</p>


<a name="output"></a>
<h2>Coreference output examples</h2>

<p>The <b>Stanford tools</b> create a list of mentions for each coreference
chain and assigns the "representative" attribute to one of the elements. Each
mention refers to sentence and token identifiers. For the text <i>"John is
sick. He is home. Jill sees her dog."</i>, we have the following output:</p>

<pre class="example">
&lt;root>
  &lt;document>
    &lt;sentences>
      &lt;sentence id="1">
        &lt;tokens>
          &lt;token id="1">&lt;word>John&lt/word>...&lt;/token>
          ...
        &lt;/tokens>
        &lt;parse>(ROOT (S (NP (NNP John)) (VP (VBZ is) (ADJP (JJ sick))) (. .))) &lt;/parse>
        &lt;dependencies type="basic-dependencies">...&lt;/dependencies>
        &lt;dependencies type="collapsed-dependencies">...&lt;/dependencies>
        &lt;dependencies type="collapsed-ccprocessed-dependencies">...&lt;/dependencies>
      &lt;/sentence>
      &lt;sentence id="2">...&lt;/sentence>
      &lt;sentence id="3">...&lt;/sentence>
    &lt;/sentences>
    &lt;coreference>
      &lt;coreference>
        &lt;mention representative="true">
          &lt;sentence>1&lt;/sentence>&lt;start>1&lt;/start>&lt;end>2&lt;/end>&lt;head>1&lt;/head>&lt;text>John&lt;/text>
        &lt;/mention>
        &lt;mention>
          &lt;sentence>2&lt;/sentence>&lt;start>1&lt;/start>&lt;end>2&lt;/end>&lt;head>1&lt;/head>&lt;text>He&lt;/text>
        &lt;/mention>
      &lt;/coreference>
      &lt;coreference>
        &lt;mention representative="true">
          &lt;sentence>3&lt;/sentence>&lt;start>1&lt;/start>&lt;end>2&lt;/end>&lt;head>1&lt;/head>&lt;text>Jill&lt;/text>
        &lt;/mention>
        &lt;mention>
          &lt;sentence>3&lt;/sentence>&lt;start>3&lt;/start>&lt;end>4&lt;/end>&lt;head>3&lt;/head>&lt;text>her&lt;/text>
        &lt;/mention>
      &lt;/coreference>
    &lt;/coreference>
  &lt;/document>
&lt;/root>
</pre>

<p>Here is some output from the <b>OpenNLP coreference</b>:</p>

<pre class="example">
OpenNLP Coreference 
-------------------------------------------------------------------------------------------------------
Input sentences 1 ::
Carol told Bob to attend the party. They arrived together.

Sentence#1 parse after POS & NER tag:
(TOP (S (NP (NNP Carol)) (VP (VBD told) (NP (NNP Bob)) (S (VP (TO to) (VP (VB attend) (NP (DT the) (NN party))))))(. .)))

Sentence#2 parse after POS & NER tag:
(TOP (S (NP (PRP They)) (VP (VBD arrived) (ADVP (RB together)))(. .)))

Now displaying all discourse entities::
        Mention set:: [ Bob  :: They  ]
        Mention set:: [ the party  ]
        Mention set:: [ Carol  ]
</pre>

<p>Here too, we have sets of mentions. From this print it is not possible to see
how internally mentions in the data structure refer to text elements, whether it
is by pointing to sentence and token identifiers, as with the Stanford tool, or
to nodes in the parse tree. This example, by the way, shows that split
antecedents are not dealt with by OpenNLP (at least, not in this case).</p>

<p>And here is the <b>ANNIE coreference</b> output from GATE. This is the
coreference component as wrapped at Vassar
(<a href="http://grid.anc.org:8080/service_manager/wsdl/anc:gate.coref_1.3.5">http://grid.anc.org:8080/service_manager/wsdl/anc:gate.coref_1.3.5</a>. The
className and itemClassName attributes were removed to make the datas tructure
easier to read.</p>

<pre class="example">
&lt;Annotation Id="28" Type="Person" StartNode="9" EndNode="13">
&lt;Feature>
  &lt;Name>matches&lt;/Name>
  &lt;Value>28;31&lt;/Value>
&lt;/Feature>
&lt;Feature>
  &lt;Name>string&lt;/Name>
  &lt;Value>John&lt;/Value>
&lt;/Feature>
&lt;/Annotation>
&lt;Annotation Id="31" Type="Person" StartNode="27" EndNode="30">
&lt;Feature>
  &lt;Name>ENTITY_MENTION_TYPE&lt;/Name>
  &lt;Value>PRONOUN&lt;/Value>
&lt;/Feature>
&lt;Feature>
  &lt;Name>antecedent_offset&lt;/Name>
  &lt;Value>9&lt;/Value>
&lt;/Feature>
&lt;Feature>
  &lt;Name>matches&lt;/Name>
  &lt;Value>28;31&lt;/Value>
&lt;/Feature>
&lt;/Annotation>
</pre>

<p>This is a fragment of the result for <i>There is John Smith. I saw him in
London</i>. This particular result was obtained from a pipeline where the
coreference occurred after named entity recognition. Without NER, there are
no coreference results (this may be a feature of the particular coreference
coponent wrapped). The NER found <i>John</i> and <i>him</i> as persons, but
not <i>Smith</i>. Coreference information is added to the Person
annotations. StartNode and EndNode refer to the character offsets, whereas
matches refers to the annotation object identifiers.

<p>Currently, we already have a default JSON structure for this because the
converters keep all features:</p>

<pre class="example">
{
  "@type" : "Person",
  "id" : "28",
  "start" : 9,
  "end" : 13,
  "features" : {
    "word" : "John",
    "matches" : [ 28, 31 ] }
}, 
{
  "@type" : "Person",
  "id" : "31",
  "start" : 27,
  "end" : 30,
  "features" : {
    "matches" : [ 28, 31 ],
    "antecedent_offset" : 9,
    "ENTITY_MENTION_TYPE" : "PRONOUN" }
}
</pre>

<p>This is not how we want to represent coreference though.</p>


<a name="lif"></a>
<h2>Coreference in the LAPPS Interchange Format</h2>

<p>Before presenting the proposed format, first some more general questions that
  play into the issue. The relevance of many of these questions are not limited
  to coreference, even though they came up in this context.</p>

<dl class="nicer">

<dt>Can elements in the coreference view refer to identifiers in other
views?</dt>

<dd>There were strong sentiments to allow this. It does not duplicate
  information, is a bit more flexible and makes for potentially more compact
  representations.</dd>

<dt>How deeply nested do we allow our JSON datastructure to be?</dt>

<dd>This refers to how much embedded structure we allow in the JSON objects that
  are in the annotations list. So far, the Token elements in this list just have
  one sub structure: the dictionary of features. The current proposed structures
  extend this a tiny bit by allowing lists for some attributes. All three
  examples of coreference in the previous section (Stanford, OpenNLP and GATE)
  all use a set or list to group mentions/matches. The only way to avoid this
  would be to introduce annotation objects in a coreference chain that link just
  two elements of a chain. This question on nesting becomes more salient when we
  start wrapping tree structures.</dd>

<dt>Is coreference its own annotation object?</dt>

<dd>Yes. Nobody liked the approach of having corefence expressed as an attribute
or set of attributes on Token or Person objects (which is what GATE does). From
this it follows that Coreference will have its own page in the LAPPS
vocabulary.</dd>

<dt>Is coreference expressed as a coreference chain (linked list) or as a set?</dt>
 
<dd>In the first case, each link in the chain would be represented by a
Coreference object, which would have references to the two objects linked. The
previous version of this document had this as an option, but it ran into a few
little snags. Using a set to represent a list of mentions is common to all three
example coreference modules in the previous section. One advantage of using a
list may be that no list values are needed inside the Coreference object. We
felt that using a set was the better way.</dd>

<dt>How do we represent the text elements that are coreferring?</dt>

<dd>In some cases, there will be annotation objects in another view that can be
  used and in some cases new objects will need to be made. We discussed a
  Markable object that could fill this need.</dd>

<dt>Do we want to aim for views that somehow give away what views they depend on?</dt>

<dd>The metadata of a view specify who created the view. The metadata of this
  producer will have input requirements specified, but won't tell you where to
  get them. The output data in the views do not necessarily say what other view
  data were used, excepts when an object refers to an identifier in another
  view. But these identifiers are not unique in our current scheme (see
  below). We could add metadata that says what views were consumed, but that is
  adding more work to the wrapper. And it is not even clear whether this
  question is actually important.</dd>

<dt>What is the status of the id attribute on the annotation objects?</dt>

<dd>This is tricky from a conceptual angle (I think). We now have a situation
  where two views (from the tokenizer and tagger for example) can have Token
  objects with the same identifier. Is this confusing? I find it somehwat
  confusing to have two different JSON objects with the same identifier (they
  are different because the same Token in the tagger view has added
  attributes). Are these identifiers really references to some underlying object
  that we imply, but that does not occur in the representation explicitly? And
  do we need the identifiers for the Token objects with the same text span to be
  the same? We don't really because the Token objects also have the start and
  end offsets which are identical for the two. The identical identifiers do
  indicate that the two tokens in the two views really are the same token, if we
  require each token identifier to be unique to the document, then we loose
  this. We can make it work either way, the issue may just be to decide on what
  is easier to explain to outsiders.</dd>

<dt>Can we maintain schema similar to Steve Cassidy's?</dt>

<dd>This is an open question and we cannot say anything intelligent about it
  right now. We would need to get examples on how coreference plays out for the
  Australian National Corpus Initiative.</dd>

</dl>

<p>Time for some coreference representations in JSON. The examples below are all
for the simple phrase <i>Sue sees herself</i>. The JSON is fairly informal, just
showing the bits and pieces that are relevant to the discussion.</p>

<p>Here is an example where the Coreference view refers to elements in other
views.</p>

<pre class="example">
{
  "text": "Sue sees herself",
  "views": [ 
    { "metadata": {
        "contains": {
          "Token": {
            "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:n.n.n",
            "type": "tokenizer:opennlp" }}},
      "annotations": [ 
         { "@type": "Token", "id": "tok0", "start": 0, "end": 3 },
         { "@type": "Token", "id": "tok1", "start": 4, "end": 8 },
         { "@type": "Token", "id": "tok2", "start": 9, "end": 16 } ]},
    { "metadata": {
        "contains": {
          "Markable": {
            "producer": "edu.brandeis.cs.lappsgrid.xxxx.coref:n.n.n",
            "type": "coref:xxxx" },
          "Coreference": {
            "producer": "edu.brandeis.cs.lappsgrid.xxxx.coref:n.n.n",
            "type": "coref:xxxx" }}},
      "annotations": [
         { "@type": "Markable", "id": "m0", "targets": [ "tok0" ] },
         { "@type": "Markable", "id": "m1", "targets": [ "tok2" ] },
         { "@type": "Coreference", 
           "id": "coref0", 
           "features": {
             "mentions": [ "m0", "m1" ],
             "representative": "m0" }}]}]
}
</pre>

<p>Some notes on the Markables and Coreference elements</p>

<ol class="spacy">

<li>What is the value of type in the coreference metadata?

<li>The markables are required, the mentions list cannot refer directly to other
views. There is a slight penalty to pay, but it appears conceptually cleaner to
do it this way.

<li>Markables either have start and end or a target specified. Bur we do allow
all three to be there. This is still a little bit up for discussion though. How
can we endode this in JSON schema?

<li>We use Markable because this is a common practice for manual corefence
annotation. We need some references here.

</ol>

<p>An example where there is no other view to refer to.</p>

<pre class="example">
{
  "text": "Sue sees herself",
  "views": [ 
    { "metadata": {
        "contains": {
          "Markable": { },
          "Coreference": { } }},
      "annotations": [
         { "@type": "Markable", "id": "m0", "start": 0, "end": 3 },
         { "@type": "Markable", "id": "m1", "start": 9, "end": 16 },
         { "@type": "Coreference", 
           "id": "coref0",
           "features": {
             "mentions": [ "m0", "m1" ],
             "representative": "m0" }}]}]
}
</pre>

<p>If a coreference component generates actual annotations that can be used, but
that are not available in other views, then we put them in the coreference
view. Below we have Token annotations in the coreference view. Instead of Token
we could also have Person or NounChunk or any other Annotation type.</p>


<pre class="example">
{
  "text": "Sue sees herself",
  "views": [ 
    { "metadata": {
        "contains": {
          "Token": { },
          "Markable": { },
          "Coreference": { } }},
      "annotations": [
         { "@type": "Token", "id": "tok0", "start": 0, "end": 3 },
         { "@type": "Token", "id": "tok2", "start": 9, "end": 16 },
         { "@type": "Markable",
           "id": "m0",
           "features": {
             "targets": [ "tok0" ] }},
         { "@type": "Markable",
           "id": "m1",
           "features": {
             "targets": [ "tok2" ] }},
         { "@type": "Coreference", 
           "id": "coref0",
           "features": {
             "mentions": [ "m0", "m1" ],
             "representative": "m0" }}]}]
}
</pre>

<p>Sometimes, coreference modules will have all kinds of other information on
the annotations that are linked. For example, the ANNIE Coreference componen has
an attribute ENTITY_MENTION_TYPE with value PRONOUN on one of the
annotations. We put them in the features directory of the Markable. </p>

<pre class="example">
{
  "text": "Sue sees herself",
  "views": [ 
    { "metadata": {
        "contains": {
          "Token": { },
          "Markable": { },
          "Coreference": { } }},
      "annotations": [
         { "@type": "Token", "id": "tok0", "start": 0, "end": 3 },
         { "@type": "Token", "id": "tok2", "start": 9, "end": 16 },
         { "@type": "Markable",
           "id": "m0",
           "features": {
             "targets": [ "tok0" ] }},
         { "@type": "Markable",
           "id": "m1",
           "features": {
             "targets": [ "tok2" ],
             "ENTITY_MENTION_TYPE": "PRONOUN" } },
         { "@type": "Coreference", 
           "id": "coref0", 
           "features": {
             "mentions": [ "m0", "m1" ],
             "representative": "m0" }}]}]
}
</pre>

<p>The list of targets can be used to deal with split antecedents. For example,
in "John and Mary left, they were late", the mentions can be m1 and m2, and m1
is a Markable with "John" and "Mary" as targets. Note though that in this case
we need to be able to refer to annotation objects that contain "john" and
"Mary". If they are not available then we need to introduce markables that refer
to other markables.</p>

<pre class="example">
{
  "text": "John and Mary left, they were late",
  "views": [ 
    { "metadata": { },
      "annotations": [
         { "@type": "Markable", "id": "m0", "start": 0, "end": 4 },
         { "@type": "Markable", "id": "m1", "start": 9, "end": 13 },
         { "@type": "Markable",
           "id": "m2",
           "features": {
             "targets": [ "mo", "m1" ] }},
         { "@type": "Markable", "id": "m3", "start": 20, "end": 24 },
         { "@type": "Coreference", 
           "id": "coref0", 
           "features": {
             "mentions": [ "m2", "m3" ],
             "representative": "m2" }}]}]
}
</pre>

<p>Markables m0 and m1 could be other annotation types like Token or Person.</p>

</body>
</html>
