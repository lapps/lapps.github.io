<html>

<head>
<title>LIF Overview</title>
<link rel="stylesheet" href="../css/main.css" type="text/css" />
</head>

<body>

<p>
  <a href="index.html">LIF</a>
> <a href="">overview</a>
</p>

<h1>Overview of LIF</h1>

<p>Version 3: November 20<sup>th</sup>, 2014</p>

<p>This document contains a general overview of the LAPPS Interchange Format
(LIF), which is a JSON-LD format used to transport data between LAPPS
services.</p>

<p>The current JSON schema for LIF are at
<a href="http://vocab.lappsgrid.org/schema/lif-schema.json">
http://vocab.lappsgrid.org/schema/lif-schema.json</a>. At this point it is
dangerous to assume that the schema are in sync with the prose in these LIF
pages. Similarly, while the specifications often refer to or rely on the Lapps
vocabulary at
<a href="http://vocab.lappsgrid.org">http://vocab.lappsgrid.org</a>, it is
unwise to assume that at this point the specifications are in sync with the
vocabulary.</p>

<p>There are still a couple of open issues. These are indicated in boxes with
red dotted borders.</p>



<h2>The structure of LIF objects</h2>

<p>The top-level structure of a LIF object is as follows:</p>

<pre class="example">
{
  "@context": "http://vocab.lappsgrid.org/context-1.0.0.jsonld",
  "metadata": { },
  "text": { },
  "views": [ ]
}
</pre>

<p>There are four top-level keys: @context, metadata, text and views. The
following sub sections will describe the values of these four keys.</p>


<h3>The @context key</h2>

<p>The value here is the fixed URL
<a href="http://vocab.lappsgrid.org/context-1.0.0.jsonld">http://vocab.lappsgrid.org/context-1.0.0.jsonld</a>
which leads to a document with a JSON object that points to various parts of the
Lapps vocabulary. We allow people to provide their own context, but we do not
allow services to changes this top-level context and turn it into a
list. Instead, we allow services to add contexts to individual views or to add
elements to contexts in individual views. However, we strongly caution against
redefining terms that are defined in the external context or the vocabulary
since then some annoation objects or properties would have different meanings
depending on what view they are in. Note that the JSON-LD recommendation is not
too thrilled about this: <i>this is rarely a good authoring practice and is
typically used when working with legacy applications that depend on a specific
structure of the JSON object</i>
(<a href="http://www.w3.org/TR/json-ld/#advanced-context-usage">link</a>).</p>


<h3>The metadata key</h3>

<p>All examples of output of our services have an empty object here. There is no
current use case for what could be in this metadata object. The LIF object is
created and consumed by wrappers and metadata information added should be
relevant to and usable by these wrappers. All metadata we have so far are
relevant to individual views only and are included in the views
key. Nevertheless, we will allow a metadata key here for future use.</p>


<h3>The text key</h3>

<p>This is a JSON <a href="http://www.w3.org/TR/json-ld/#dfn-value-object">value
object</a> containing a @value and a @language key. The value associated with
@value is a string and the value associated with @language follows the rules in
<a href="http://www.w3.org/TR/json-ld/#bib-BCP47">BCP47</a>, which for our
current purposes boils down to using the ISO 639 code (also
see <a href="http://vocab.lappsgrid.org/Document.html#language">Document
section</a> in the vocabulary).


<h3>The views key</h3>

<p>This is where all the annotations and associated information live. The value
is a JSON array of views where each view specifies what information it contains
and what service created that information. Views are similar to annotation
layers and annotation tasks as used by several annotation tools, formalisms and
frameworks. They contain structured information about a text but are separated
from that text. They also provide flexibility in structuring annotations.</p>

<p>First a note on the nature of the views array. JSON-LD arrays are by default
unordered lists, but we decided to make this an ordered list. This is, or will
be, enforced in the external context, with the following lines:

<blockquote>
"@context": { "views": { "@container": "@list" } }
</blockquote>

<p>The order is interpreted to reflect when views were added. So we require that
any view added by a lif-wrapped service has to be appended to the end.</p>

<p>There are a few general principles:</p>

<ol class="spacy">

<li>There is no limit to the number of views.

<li>For each view, the metadata should specify what kind of information objects
are in the view.

<li>Services may create as many new views as they want.

<li>Services may add information to existing views.

<li>Services may overwrite or delete information in existing views. We have been
  flip-flopping on this, see below for a discussion.

<li>Services may not overwrite term definitions that were defined in the view's
context.

</ol>


<p>It may be a good idea to not allow a service to add information to an
existing view. While this introduces some redundancy (a POS service would need
to copy data from aToken view for example), it would create a clear picture
where a view, once added, can never be changed. And if a view would say on what
other view it is based, then we could derive a flow chart of what views were
used in the processing chain.</p>

<p>Here is a minimal example of a view with just one annotation element. </p>

<pre class="example">
"views": [ 
   {
      "@context": {},
      "id": "v0",
      "metadata": {
        "contains": {
          "Token": {
            "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
            "type": "tokenization:opennlp",
            "rules": "tokenization:opennlp_basic"
          }
        }
      },
      "annotations": [ 
         { "@type": "Token", 
           "id": "t0", 
           "start": 0, 
           "end": 5, 
           "features": {} 
         }
      ]
   }
]
</pre>

<p>There are four keys in the view object: @context, id, metadata and
annotations.</p>

<p>The <b>@context</b> key is an optional key used for user-defined context
elements. As noted before, this is one of two possible choices on how to do
this. One of the general principles listed above was that services may add
information to existing views. Typically this would involve adding a feature to
the Annotation element dictionary or adding an Annotation element. </p>

<p>The question is what we do when the newly added feature or annotation element
is not defined in our vocabulary or is interpreted differently by the
service. To deal with the first case the service can simply add the needed term
to the local context, as illustrated in the view fragment below.</p>

<pre class="example">
{
  "@context": { "MyToken": "http:/www/example.com/MyToken" },
  "annotations": [ 
    { "@type": "MyToken", "id": "t0", "start": 0, "end": 5 } ]
}
</pre>

<p>The second case is more complicated. Say the service creates Token elements but
these elements have an idiosyncratic interpretation which cannot be explained
away by using the <code>type</code> or <code>rules</code> keys (see below). And,
more importantly (and a more likely scenario), say the service adds Token
elements to a view that already has Token elements. Adding a Token definition to
the context in the existing view now overwrites the existing interpretation of
Token, which is not acceptable. There are several solutions: 

<ol class="spacy">

<li>Do not allow a service to redefine a term that was not added by the
service. This would be rather hard to enforce.</li>

<li>Do not allow services to change the context of an existing view. With this
approach, services that want to use their own context definitions either have to
create a new view for adding that context or use a fully expanded URI. There
would still be a problem if you have two kinds of Tokens in a view (because
Tokens might be copied from the view with another definition of Token), it would
then be impossible to say who was the producer.

<li> Decide that, despite the grouchy statement above, this is in fact
acceptable. If we allow a service to change a view by changing or deleting
annotations, then it would fall in that spirit to also allow redefinition of
terms.

</ol>

<p class="issue">Agree on how to deal with this. It looks like we tentatively
decided on the third solution.</p>

<p>The <b>id</b> keys is required and its value should be unique relative to all
view objects. If Annotation elements refer to an Annotation in another view then
it has to use the view identifier as part of the reference.</p>

<p>We have several times touched upon the issue of identifiers in LIF. This is
tricky from a conceptual angle (I think). We now have a situation where two
views (from the tokenizer and tagger for example) can have Token objects with
the same identifier. Is this confusing? I find it somehwat confusing to have two
different JSON objects of the same type with the same identifier. What is equal
about these two objects is that they refer to the same text span, but they can
have different features (for example, our current POS tags view has Token
objects with the same identifier and offsets as Token objects in the token
views, but the former has an extra feature posTag in the features
dictionary).</p>

<p>Are these identifiers really references to some underlying object that we
imply, but that does not occur in the representation explicitly? And what if
these two Token objects have conflicting information? The latter could happen if
we have two taggers working on the same tokens but adding different pos tags.

Do we need the identifiers for the Token objects with the same text span to be
the same? We don't really because the Token objects also have the start and end
offsets which are identical for the two. The identical identifiers do indicate
that the two tokens in the two views really are the same token, if we require
each token identifier to be unique to the document, then we loose this. Before
we had view identifiers we also had an issue with referring to a specific token,
this is now not an issue anymore.</p>

<p class="issue">At some point we need to decide on what to do with
identifiers. For now, we are happy to leave this unresolved.</p>


<p>The <b>metadata</b> key contains information to describe the annotations in a
view. At this point, its only key is <code>contains</code>. We have shortly
discussed the idea of adding a timestamp, probably using Unix epoch, and, in
addition, using a key like <code>dependsOn</code> might be useful too (see the
beginning of the views section). The <code>contains</code> dictionary has keys
that refer to Annotation objects in the Lapps vocabulary or properties of those
annotation objects (they can also refer to user-defined objects or
properties). And the value of each of those keys is a JSON object
with <code>producer</code>, <code>type</code> and <code>rules</code> keys. The
relevant part of the example above is repeated here:</p>

<pre class="example">
{
  "contains": {
    "Token": {
      "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
      "type": "tokenization:opennlp",
      "rules": "tokenization:opennlp_basic" }}
}
</pre>

<p>The <code>producer</code> key contains a string that specifies what service
created the annotation data. Unfortunately, this string cannot be the unique
name that the LAPPS grid has for this service, nor can it be the URL where the
service resides. The reason for this is that the service itself has no access to
this information and it is the service (actually, the service wrapper) that adds
information to the LIF objects. The current convention is to use the java class
name of the service and the producer name is actually added to the LIF object by
accessing a name or identifier method on the server.</p>

<p class="issue">Thinking this through again I still feel somewhat uneasy about
this. We cannot guarantee any kind of uniqueness of this name and this brings up
the specter that this value may be misleading or useless. Three potential
solutions. One is to make the value a URI, but as Keith pointed out this may
raise the expectation that said URI is an actual page and adds the soft
requirement to put up that page. Another is to make sure the service knows who
it is by changing the execute method and add an optional extra argument with the
URI or unique name of the service. We can do this because the composer or the
lsd/groovy script that composes services does have access to the unique name
(for example, the composer has access to the end point URL). The last solution
is to not care that this value is not an identifier.<br/>
<br/>
Another issue is whether there a clear use case for this feature.<br/>
<br/>
We decided to leave this unresolved for now.</p>

<p>The <code>type</code> key is used to specify what kind of token we are
dealing with. It allows several tokenizers to specify the same type, for example
if two tokenizers are both implementations of the OpenNLP tokenization scheme. In
the example here the type key has the compact IRI value tokenization:opennlp,
where tokenization refers to the tokenization key in the external context file
in <a href="http://vocab.lappsgrid.org/context-1.0.0.jsonld">http://vocab.lappsgrid.org/context-1.0.0.jsonld</a>,
which contains the following two lines:

<pre class="example">
    "types": "http://vocab.lappsgrid.org/types/",
    "tokenization": "types:tokenization/",
</pre>

<p>Because of these definitions, <code>tokenization:opennlp</code> will be expanded to
http://vocab.lappsgrid.org/types/tokenization/opennlp. The <code>rules</code>
key inside of Token can be used to specify a rule set, in this case one defined at 
http://vocab.lappsgrid.org/types/tokenization/opennlp_basic.</p>

<p>Note that in the vocabulary producer and rules are both defined as metadata
properties on Token (albeit inherited from Annotation) as well as under
http://vocab.lappsgrid.org/meta. The type key on the other hand is defined only
in the metadata area of the vocabulary.</p>


<p class="issue">Well, they are not in the metadata section yet. Also, we have
planned to change this into http://vocab.lappsgrid.org/ns or
http://vocab.lappsgrid.org/ns/schema or something else, but we should check our
notes on that.</p>

<!--
<pre class="issue">
We have
    "Token": {
        "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
        "type": "tokenizer:opennlp"
Should this be
    "Token": {
        "token:producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
        "lif:type": "tokenizer:opennlp"
Avoids ambiguous references. Or just the lif:, not the token:, or using Token:.
</pre>
-->

<p>Finally, the value of <b>annotations</b> is a list of annotation objects. The
relevant part of the view printed above is repeated here: </p>

<pre class="example">
"annotations": [ 
  { "@type": "Token", 
    "id": "t0", 
    "start": 0, 
    "end": 5, 
    "features": {} 
  }
</pre>

<p>The keys allowed are specified in the 
<a href="http://vocab.lappsgrid.org/schema/lif-schema.json">
JSON LIF schema</a> in the definitions for <code>annotations</code>
and <code>annotation</code>. The value of <code>@type</code> is an element of
the LAPPS vocabulary or an annotation category added by the user. But, as
mentioned above, note that if a user-definition is added it would be defined
outside of the LAPPS vocabulary. In that case the user should either use the
full URI or add a context to the view in which this new annotation category
lives.</p>

<p>Technically all that is required of the keys in the features dictionary is
that they expand to a URI. In most cases, the keys reflect properties in the
LAPPS vocabulary and we prefer to use the same name. So if we have a property
"posTag", we will use "posTag" in the dictionary. This implies that "posTag"
needs to be defined in the context so that it can be expanded to the correct URI
in the vocabulary. This in turn implies that in the vocabulary, each property
should be only defined once. </p>

<p>User-defined properties need to be defined in the view where they are added
or full URI must be used.</p>

</body>
</html>
