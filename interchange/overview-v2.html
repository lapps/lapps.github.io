<html>

<head>
<title>LIF Overview</title>
<link rel="stylesheet" href="../css/main.css" type="text/css" />
</head>

<body>

<p>
  <a href="index.html">LIF</a>
> <a href="">overview</a>
</p>

<h1>Overview of LIF</h1>

<p>Version 2: November 11<sup>th</sup>, 2014</p>

<p>This document contains a general overview of the LAPPS Interchange Format
(LIF), which is a JSON-LD format used to tranport data between LAPPS
services.</p>

<p>The current JSON schema for LIF are at
<a href="http://vocab.lappsgrid.org/schema/lif-schema.json">
http://vocab.lappsgrid.org/schema/lif-schema.json</a>. At this point it is
dangerous to assume that the schema are in sync with the prose in these LIF
pages. Similarly, while the specifications often refer to or rely on the Lapps
vocabulary at
<a href="http://vocab.lappsgrid.org">http://vocab.lappsgrid.org</a>, it is
unwise to assume that at this point the specifications are in sync with the
vocabulary.</p>

<p>There are still many open issues. These are indicated in boxes with red
dotted borders.</p>



<h2>The structure of LIF objects</h2>

<p>The top-level structure of a LIF object is as follows:</p>

<pre class="example">
{
  "@context": "http://vocab.lappsgrid.org/context-1.0.0.jsonld",
  "metadata": { },
  "text": { },
  "views": [ ]
}
</pre>

<p>There are four top-level keys: @context, metadata, text and views. The
following sub sections will describe the values of these four keys.</p>


<h3>The @context key</h2>

<p>The value here is the fixed URL
<a href="http://vocab.lappsgrid.org/context-1.0.0.jsonld">http://vocab.lappsgrid.org/context-1.0.0.jsonld</a>
which leads to a document with a JSON object that points to various parts of the
Lapps vocabulary. One question is whether we allow people to provide their own
context. It seems that the answer should clearly be yes.  As far as I can see
there are two ways to deal with this. One is to change the value of @context
into a list and allow services to add their own definitions:</p>

<pre class="example">
{
  "@context": [
    "http://vocab.lappsgrid.org/context-1.0.0.jsonld",
    {
      "Token": "http://example.com/types/Token",
      "pos": "http://example.com/types/Token#posTag"
    }
  ]
}
</pre>

<p>There is a serious problem with this given how JSON-LD deals with this: <i>if
a term is redefined within a context, all previous rules associated with the
previous definition are removed</i>
(<a href="http://www.w3.org/TR/json-ld/#advanced-context-usage">link</a>). So if
the extrenal vocab file contains a definition of Token or pos, then these will
be overwritten by the user-defined terms. In addition, even if the external file
does not have a definition for the Token term, it still has the line</p>

<pre class="example">
"@vocab" : "http://vocab.lappsgrid.org/",
</pre>

<p>which makes sure that Token expands to http://vocab.lappsgrid.org/Token. It is
not clear how this is dealt with.</p>

<p>The other option is to not allow this key to be edited and to specify that
user contexts be added to the annotation views (see below). Note that the
JSON-LD recommendation is not too thrilled about this: <i>this is rarely a good
authoring practice and is typically used when working with legacy applications
that depend on a specific structure of the JSON object</i>
(<a href="http://www.w3.org/TR/json-ld/#advanced-context-usage">link</a>).</p>

<p class="issue">Confirm that we allow services to define their own context and
coinfirm that this indeed needs to be done in the view. Find out how the Token
issue and other cases of ambiguity are dealt with.</p>


<h3>The metadata key</h3>

<p>All examples of output of our services have an empty object here. I have no
intuitions on what should be in here. The LIF object is created and consumed by
wrappers and metadata information added should be relevant to and usable by
these wrappers. All metadata we have so far are relevant to individual views
only and are included in the views key.</p>

<p class="issue">Decide whether the metadata key is useful. If it isn't we can
  still keep it around as a placeholder or remove it alltogether.</p>


<h3>The text key</h3>

<p>This is a JSON <a href="http://www.w3.org/TR/json-ld/#dfn-value-object">value
object</a> containing a @value and a @language key. The value associated with
@value is a string and the value associated with @language follows the rules in
<a href="http://www.w3.org/TR/json-ld/#bib-BCP47">BCP47</a>, which for our
current purposes boils down to using the ISO 639 code (also
see <a href="http://vocab.lappsgrid.org/Document.html#language">Document
section</a> in the vocabulary).


<h3>The views key</h3>

<p>This is where all the annotations and associated information live. The value
is a JSON array of views where each view specifies what information it contains
and what service created that information. Views are similar to annotation
layers and annotation tasks as used by several annotation tools, formalisms and
frameworks. They contain structured information about a text but are separated
from that text. They also provide flexibility in structuring annotations.</p>

<p>There are a few general principles:</p>

<ol>

<li>There is no limit to the number of views.

<li>Services may create as many new views as they want.

<li>Services may add information to existing views.

<li>Services may not overwrite information in existing views.

<li>Services may not overwrite term definitions that were defined in the view's
context.

</ol>


<p>First a note on the nature of the views array. We need to decide whether this
array is ordered or unordered. We could require that any view added by a
lif-wrapped service has to be appended to the end and with an ordered array we
could then read the processing history from the views list. If we want to do
that we would have to change the value of "views" since a JSON-LD array is by
default unordered and make it look like</p>

<blockquote>
"views": { "@list": [ ... ] }
</blockquote>

<p>Alternatively, this can be done in the context:</p>

<blockquote>
"@context": { "views": { "@container": "@list" } }
</blockquote>

<p>The advantages of unordered views is that this is the least effort and it
makes the fewest assumptions. The advantage of an ordered list of views is that
this is an easy way to express some piece of information. We would have to be
clear though what exactly the order means and enforce it.</p>

<p class="issue">Decide whether views are ordered.</p>

<p>It may be a good idea to not allow a service to add information to an
existing view. While this introduces some redundancy (a POS service would need
to copy data from aToken view for example), it would create a clear picture
where a view, once added, can never be changed. And if a view would say on what
other view it is based, then we could derive a flow chart of what views were
used in the processing chain.</p>

<p class="issue">Decide whether principle 3 makes sense.</p>


<p>Here is a minimal example of a view with just one annotation element. </p>

<pre class="example">
"views": [ 
   {
      "@context": {},
      "id": "v0",
      "metadata": {
        "contains": {
          "Token": {
            "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
            "type": "tokenization:opennlp",
            "rules": "tokenization:opennlp_basic"
          }
        }
      },
      "annotations": [ 
         { "@type": "Token", 
           "id": "t0", 
           "start": 0, 
           "end": 5, 
           "features": {} 
         }
      ]
   }
]
</pre>

<p>There are four keys in the view object: @context, id, metadata and
annotations.</p>

<p>The <b>@context</b> key is an optional key used for user-defined context
elements. As noted before, this is one of two possible choices on how to do
this. One of the general principles listed above was that services may add
information to existing views. Typically this would involve adding a feature to
the Annotation element dictionary or adding an Annotation element. </p>

<p>The question is what we do when the newly added feature or annotation element
is not defined in our vocabulary or is interpreted differently by the
service. To deal with the first the service can simply add the needed term to
the local context, as illustrated in the view fragment below.</p>

<pre class="example">
{
  "@context": { "MyToken": "http:/www/example.com/MyToken" },
  "annotations": [ 
    { "@type": "MyToken", "id": "t0", "start": 0, "end": 5 } ]
}
</pre>

<p>The second is more complicated. Say the service creates Token elements but
these elements have an idiosyncratic interpretation which cannot be explained
away by using the <code>type</code> or <code>rules</code> keys (see below). And,
more importantly (and a more likely scenario), say the service adds Token
elements to a view that already has Token elements. Adding a Token definition to
the context in the existing view now overwrites the existing interpretation of
Token, which is not acceptable. There are two solutions: (i) do not allow a
service to redefine a term that was not added by the service, and (ii) do not
allow services to change the context of a view. The latter has my preference
because the former is so much harder to do and to enforce. Note also that if you
have two kinds of Tokens in a view it is impossible to say who was the
producer. With the latter approach, services that want to use their own context
definitions either have to create a new view for adding that context or use a
fully expanded URI.</p>

<p class="issue">Agree on how to deal with this.</p>

<p>The <b>id</b> keys is required and its value should be unique relative to all
view objects. If Annotation elements refer to an Annotation in another view then
it has to use the view identifier as part of the reference.</p>

<p>We have several times touched upon the issue of identifiers in LIF. This is
tricky from a conceptual angle (I think). We now have a situation where two
views (from the tokenizer and tagger for example) can have Token objects with
the same identifier. Is this confusing? I find it somehwat confusing to have two
different JSON objects of the same type with the same identifier. What is equal
about these two objects is that they refer to the same text span, but they can
have different features (for example, our current POS tags view has Token
objects with the same identifier and offsets as Token objects in the token
views, but the former has an extra feature posTag in the features
dictionary).</p>

<p>Are these identifiers really references to some underlying object that we
imply, but that does not occur in the representation explicitly? And what if
these two Token objects have conflicting information? The latter could happen if
we have two taggers working on the same tokens but adding different pos tags.

Do we need the identifiers for the Token objects with the same text span to be
the same? We don't really because the Token objects also have the start and end
offsets which are identical for the two. The identical identifiers do indicate
that the two tokens in the two views really are the same token, if we require
each token identifier to be unique to the document, then we loose this. Before
we had view identifiers we also had an issue with referring to a specific token,
this is now not an issue anymore.</p>

<p class="issue">Decide on what to do with identifiers.</p>


<p>The <b>metadata</b> key contains information to describe the annotations in a
view. At this point, its only key is <code>contains</code>. We have shortly
discussed the idea of adding a timestamp, probably using Unix epoch, and, in
addition, using a key like <code>dependsOn</code> might be useful too (see the
beginning of the views section). The <code>contains</code> dictionary has keys
that refer to Annotation objects in the Lapps vocabulary or properties of those
annotation objects (they can also refer to user-defined objects or
properties). And the value of each of those keys is a JSON object
with <code>producer</code>, <code>type</code> and <code>rules</code> keys. The
relevant part of the example above is repeated here:</p>

<pre class="example">
{
  "contains": {
    "Token": {
      "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
      "type": "tokenization:opennlp",
      "rules": "tokenization:opennlp_basic" }}
}
</pre>

<p>The <code>producer</code> key contains a string that specifies what service
created the annotation data. Unfortunately, this string cannot be the unique
name that the LAPPS grid has for this service, nor can it be the URL where the
service resides. The reason for this is that the service itself has no access to
this information and it is the service (actually, the service wrapper) that adds
information to the LIF objects. The current convention is to use the java class
name of the service and the producer name is actually added to the LIF object by
accessing a name or identifier method on the server.</p>

<p class="issue">Thinking this through again I still feel somewhat uneasy about
this. We cannot guarantee any kind of uniqueness of this name and this brings up
the specter that this value may be misleading or useless. Three potential
solutions. One is to make the value a URI, but as Keith pointed out this may
raise the expectation that said URI is an actual page and adds the soft
requirement to put up that page. Another is to make sure the service knows who
it is by changing the execute method and add an optional extra argument with the
URI or unique name of the service. We can do this because the composer or the
lsd/groovy script that composes services does have access to the unique
name. The last solution is to not care that this value is not an identifier.</p>

<p class="issue">Also, is there a clear use case for this feature.</p>

<p>The <code>type</code> key is used to specify what kind of token we are
dealing with. It allows several tokenizers to specify the same type, for example
if two tokenizers are both implementations of the the OpenNLP tokenization. In
the example here the type key has the compact IRI value tokenization:opennlp,
where tokenization refers to the tokenization key in the context defined
in <a href="http://vocab.lappsgrid.org/context-1.0.0.jsonld">http://vocab.lappsgrid.org/context-1.0.0.jsonld</a>,
which contains the following two lines:

<pre class="example">
    "types": "http://vocab.lappsgrid.org/types/",
    "tokenization": "types:tokenization/",
</pre>

<p>So <code>tokenization:opennlp</code> will be expanded to
<code>http://vocab.lappsgrid.org/types/tokenization/opennlp</code>. The <code>rules</code>
key inside of Token can be used to specify a rule set. Assuming it expands to
http://vocab.lappsgrid.org/types//opennlp_basic, it can use the same expansion
as used by tokenization:opennlp.</p>

<p>Note that in the vocabulary producer and rules are both defined as metadata
properties on Token (albeit inherited from Annotation) as well as under
http://vocab.lappsgrid.org/meta. The type key on the other hand is defined only
in the metadata area of the vocabulary.</p>


<p class="issue">Well, they are not in the metadata section yet. Also, we have
planned to change this into http://vocab.lappsgrid.org/ns or
http://vocab.lappsgrid.org/ns/schema or something else, but we should check our
notes on that.</p>

<!--
<pre class="issue">
We have
    "Token": {
        "producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
        "type": "tokenizer:opennlp"
Should this be
    "Token": {
        "token:producer": "edu.brandeis.cs.lappsgrid.opennlp.Tokenizer:0.0.4",
        "lif:type": "tokenizer:opennlp"
Avoids ambiguous references. Or just the lif:, not the token:, or using Token:.
</pre>
-->

<p>Finally, the value of <b>annotations</b> is a list of annotation objects. The
relevant part of the view printed above is repeated here: </p>

<pre class="example">
"annotations": [ 
  { "@type": "Token", 
    "id": "t0", 
    "start": 0, 
    "end": 5, 
    "features": {} 
  }
</pre>

<p>The keys allowed are specified in the 
<a href="http://vocab.lappsgrid.org/schema/lif-schema.json">
JSON LIF schema</a> in the definitions for <code>annotations</code>
and <code>annotation</code>. The value of <code>@type</code> is an element of
the LAPPS vocabulary or an annotation category added by the user. But, as
mentioned above, note that if a user-definition is added it would be defined
outside of the LAPPS vocabulary. In that case the user should either use the
full URI or add a context to the view in which this new annotation category
lives.</p>

</body>
</html>
